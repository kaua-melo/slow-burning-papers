
#include "ParticleChain1D.h"



ParticleChain1D::ParticleChain1D(int x, int y, int l, int _np, float _str, float f, float w, ofColor _c)
{
	// position of the first tip (first particle)
	pos.set(ofVec2f(x,y));

	// length of the chain
	length = l;

	// number of particles
	np = _np;

	// space between two particles
	gap = length/(np-1);

	// strength of the connection
	str = _str;

	// friction each particle suffer
	friction = f;

	// How thick is the chain/particle
	weight = w;

	// chain's color
	c = _c;


	float angle = 6.28/np;
	r		= length/6.28;
	// center of the bubble
	center = ofVec2f(ofGetWindowWidth()/2,ofGetWindowHeight()/2);


	// Creating particles
	for(int i =0; i<np; i++)
	{
		ofVec2f position = ofVec2f(center.x+r*cos(i*angle), center.y+r*sin(i*angle));
														//Particle(int x, int y, int _r, float f)
		//shared_ptr<Particle> tempParticle = shared_ptr<Particle>(new Particle(pos.x+i*gap, pos.y, weight, friction));

		shared_ptr<Particle> tempParticle = shared_ptr<Particle>(new Particle(position.x, position.y, weight, friction));


		p.push_back(tempParticle);
	}
}


void ParticleChain1D::update()
{
	// FIRST PARTICLE -------------------------------------
		// Connecting first particle with the second
		// ----------------------------------
/*		// Attract only if the distance is greater than gap
		if(p[0]->pos.distance(p[1]->pos) > gap)
		{
			ofVec2f f = p[1]->pos - p[0]->pos;
			f.scale(f.length() - gap);	
			f *= str;

			p[0]->addForce(f);
		}	
*/		

		// always attract
		p[0]->addForce( (p[1]->pos - p[0]->pos)*str);
		// ----------------------------------

		// Connecting first particle with the last
		// ----------------------------------
		    // Attract only if the distance is greater than gap
/*			if(p[0]->pos.distance(p[np-1]->pos) > gap)
			{
				ofVec2f f = p[np-1]->pos - p[0]->pos;
				f.scale(f.length() - gap);	
				f *= str;

				p[0]->addForce(f);
			}	
*/

			// always attract
			p[0]->addForce( (p[np-1]->pos - p[0]->pos)*str);
		// ----------------------------------
	// ----------------------------------------------------



	// connecting the particles from the middle
	for(int i=1; i< np-1; i++)
	{
		// Connecting with the right particle
		// ----------------------------------
/*		    // Attract only if the distance is greater than gap
			if(p[i]->pos.distance(p[i+1]->pos) > gap)
			{
				ofVec2f f = p[i+1]->pos - p[i]->pos;
				f.scale(f.length() - gap);	
				f *= str;

				p[i]->addForce(f);
			}	
*/

			// always attract
			p[i]->addForce( (p[i+1]->pos - p[i]->pos)*str);
		// ----------------------------------




		// Connecting with the left particle
		// ----------------------------------
		    // Attract only if the distance is greater than gap
/*			if(p[i]->pos.distance(p[i-1]->pos) > gap)
			{
				ofVec2f f = p[i-1]->pos - p[i]->pos;
				f.scale(f.length() - gap);	
				f *= str;

				p[i]->addForce(f);
			}	
*/

			// always attract
			p[i]->addForce( (p[i-1]->pos - p[i]->pos)*str);
		// ----------------------------------
	}


	// LAST PARTICLE --------------------------------------
		// Connecting last particle with the second last
		// ----------------------------------
		// Attract only if the distance is greater than gap
/*		if(p[np-1]->pos.distance(p[np-2]->pos) > gap)
		{
			ofVec2f f = p[np-2]->pos - p[np-1]->pos;
			f.scale(f.length() - gap);	
			f *= str;

			p[np-1]->addForce(f);
		}	
*/

		// always attract
		p[np-1]->addForce( (p[np-2]->pos - p[np-1]->pos)*str);
		// ----------------------------------


		// Connecting last particle with the first
		// ----------------------------------
		// Attract only if the distance is greater than gap
/*		if(p[np-1]->pos.distance(p[0]->pos) > gap)
		{
			ofVec2f f = p[0]->pos - p[np-1]->pos;
			f.scale(f.length() - gap);	
			f *= str;

			p[np-1]->addForce(f);
		}	
*/

		// always attract
		p[np-1]->addForce( (p[np-2]->pos - p[np-1]->pos)*str);
		// ----------------------------------
	// ----------------------------------------------------


	for(int i=0; i<np; i++)
	{
		p[i]->update();
	}
}



void ParticleChain1D::drawP()
{

	//ofDrawCircle(center.x, center.y, r);


	for(int i=0; i<np; i++)
	{
		p[i]->draw();
	}
}


void ParticleChain1D::drawL()
{
	ofPolyline line;

	// for first connection (particle 0 and 1)
	line.curveTo(p[0]->pos);
	line.curveTo(p[0]->pos);

	// connections between particles in the middle
	for(int i=1; i<np; i++)
	{
		line.curveTo(p[i]->pos);
	}

	// for last particle
	line.curveTo(p[np-1]->pos);

	//line.draw();


	// There are two ways of setting the weight 
	// of a line in OF: ofSetLineWidth(2) and glLineWidth(20);
	// Both of the ways has a weight maximum limit.
	// Here's what I did to workaround it:
	ofVec2f v = line.getPointAtLength(0);

	ofSetColor(c);
	int index=0;
	while( index < line.getPerimeter() )
	{
		v = line.getPointAtLength(index);
		ofDrawEllipse(v.x, v.y, 2*weight, 2*weight);
		index+=1;
	}

	v = line.getPointAtLength(line.getPerimeter());
	ofDrawEllipse(v.x, v.y, 2*weight, 2*weight);
}

